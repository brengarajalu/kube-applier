#!/usr/bin/env python2.7

# A lightweight wrapper around the kubectl command.
# kubectl 1.5.x has problems with ThirdPartyResources and apply. This script
# determines apply usage with ThirdPartyResources and executes create || replace
# for the ThirdPartyResource instead of apply.
# TODO: This wrapper is essentially a hack and should be removed once we move to 1.6

from __future__ import print_function
import argparse
import subprocess
import os
import logging
import sys
import tempfile
import json

def actual_kubectl_path():
    """ Return the path to the actual kubectl binary"""
    ulp = "/usr/local/bin/kubectl"
    if os.path.isfile(ulp):
        return ulp

    up = "/usr/bin/kubectl"

    if os.path.isfile(up):
        return up

    raise RuntimeError("Could not find actual kubectl executable")

def call_vanilla_kubectl(params):
    """ Pass through call to the vanila kubectl"""
    cmd = [actual_kubectl_path()] + params

    logging.debug("Calling CMD  {}".format(cmd))
    try:
        subprocess.check_call(cmd)
    except subprocess.CalledProcessError as e:
        sys.exit(1)

def is_broken_with_apply(obj):
    """Return true if the obj type is known to be broken with TPR"""

    broken_kinds = ["Pki"]

    k = obj.get("kind")
    return k in broken_kinds


def write_objs_to_file(objs):
    """Write the json representations of the given objects in a temp file.
    Separate the objs with delimiter "---" and return the file descriptor
    handle"""
    with tempfile.NamedTemporaryFile(delete=False) as f:
        f.write("\n---\n")
        for o in objs:
            json.dump(o, f, sort_keys=True, indent=3, separators=(',', ': '))
            f.write("\n---\n")
    return f

def call_create_or_replace(filename):
    """For objs that are broken with apply, we will execute create or replace"""

    cmd = [actual_kubectl_path(), "create", "-f", filename]
    logging.debug("Calling CMD  {}".format(cmd))

    try:
        subprocess.check_call(cmd)
    except subprocess.CalledProcessError as e:

        cmd = [actual_kubectl_path(), "replace", "-f", filename]
        logging.debug("Calling CMD  {}".format(cmd))

        try:
            subprocess.check_call(cmd)
        except subprocess.CalledProcessError as e:
            raise

def delete_file(f):
    try:
        os.remove(os.path.abspath(f.name))
    except OSError:
        pass


def handle_apply_with_filename(params, other_params, filename):
    """Apply command has been called with a filename.
    We parse the filename and see if there is a TPR in it.
    If there is a TPR we special handle it. Otherwise it is a pass through"""

    p = os.path.abspath(filename)
    if not os.path.exists(p) or not os.path.isfile(p):
        # The filename does not exist, fall back to original kubectl so that
        # it can handle the error.
        call_vanilla_kubectl(params)
        return

    with open(p) as f:
        contents = f.read().strip()
        jsons = contents.split("---")
        objs = [json.loads(j) for j in jsons if len(j)>0]

        apply_ok = [o for o in objs if not is_broken_with_apply(o)]
        apply_broken = [o for o in objs if is_broken_with_apply(o)]

    if len(apply_broken) == 0:
        # This file  does not contain any object that is known to be broken
        # with apply
        call_vanilla_kubectl(params)
        return

    if len(apply_ok) > 0:
        f = write_objs_to_file(apply_ok)

        cmd = [actual_kubectl_path(), "apply", "-f", f.name] + other_params

        logging.debug("Calling CMD  {}".format(cmd))
        try:
            subprocess.check_call(cmd)
        except subprocess.CalledProcessError as e:
            sys.exit(1)
        else:
            delete_file(f)

    f = write_objs_to_file(apply_broken)
    call_create_or_replace(f.name)
    delete_file(f)

def handle_apply(params):
    """If the kubectl command is apply, we need to take a look at the passed file
    and handle the ThirdPartyResources differently"""

    parser = argparse.ArgumentParser()
    parser.add_argument(
        "cmd",
        choices=["apply"])
    parser.add_argument("-f","--filename")

    args, unknown_args = parser.parse_known_args(params)

    if args.filename == None:
        # apply is called without the -f --filename argument. Pass through
        call_vanilla_kubectl(params)
    else:
        handle_apply_with_filename(params, unknown_args, args.filename)

def initLog():
    logging.basicConfig(
        format='%(asctime)s %(message)s',
        stream=sys.stdout,
        level=os.environ.get("LOG","INFO"))

def main():
    initLog()
    logging.info("Running kubectl via a wrapper")

    params = sys.argv[1:]

    if os.environ.get("ORIGINAL_KUBECTL",None):
        # Add a passthrough switch in case this causes any inconvenience.
        call_vanilla_kubectl(params)
        return

    if "apply" in params:
        handle_apply(params)
    else:
        call_vanilla_kubectl(params)

if __name__ == '__main__':
    main()

